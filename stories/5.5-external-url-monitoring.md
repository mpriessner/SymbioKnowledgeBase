# Story 5.5: Implement External URL Monitoring

## Metadata
- **Epic:** Epic 5 â€” Living Documentation System
- **Points:** 5
- **Priority:** Medium
- **Status:** ðŸ”² Not Started

## Description
Create a scheduler that monitors external URLs for changes and triggers appropriate subscription behaviors.

## User Story
*As a user, I want to subscribe to external URLs so that I'm notified when vendor documentation changes.*

## Acceptance Criteria
- [ ] Scheduler checks URL subscriptions periodically
- [ ] Fetches URL content and computes hash
- [ ] Compares with stored lastHash
- [ ] If changed: fetches full content, extracts text
- [ ] Creates notification or auto-update based on behavior
- [ ] Handles rate limiting, errors, redirects gracefully
- [ ] Respects robots.txt
- [ ] Logs check history

## Technical Details

### Scheduler Service
```typescript
// src/lib/livingDocs/urlMonitor.ts
import { createHash } from 'crypto';

interface MonitorResult {
  subscriptionId: string;
  changed: boolean;
  newHash?: string;
  content?: string;
  error?: string;
}

async function checkUrlSubscriptions(): Promise<MonitorResult[]> {
  const subscriptions = await prisma.documentSubscription.findMany({
    where: {
      sourceType: 'URL',
      isActive: true,
      OR: [
        { lastCheckedAt: null },
        { lastCheckedAt: { lt: new Date(Date.now() - checkInterval * 1000) } }
      ]
    }
  });
  
  const results: MonitorResult[] = [];
  
  for (const sub of subscriptions) {
    try {
      const content = await fetchAndExtract(sub.sourceId);
      const hash = createHash('sha256').update(content).digest('hex');
      
      if (hash !== sub.lastHash) {
        results.push({ subscriptionId: sub.id, changed: true, newHash: hash, content });
        await handleChange(sub, content);
      }
      
      await prisma.documentSubscription.update({
        where: { id: sub.id },
        data: { lastCheckedAt: new Date(), lastHash: hash }
      });
    } catch (error) {
      results.push({ subscriptionId: sub.id, changed: false, error: error.message });
    }
  }
  
  return results;
}
```

### Fetch & Extract
```typescript
async function fetchAndExtract(url: string): Promise<string> {
  // Check robots.txt
  const robotsAllowed = await checkRobotsTxt(url);
  if (!robotsAllowed) throw new Error('Blocked by robots.txt');
  
  // Fetch with timeout and retry
  const response = await fetch(url, {
    headers: { 'User-Agent': 'SymbioKnowledgeBase/1.0' },
    signal: AbortSignal.timeout(30000)
  });
  
  const html = await response.text();
  
  // Extract main content (skip nav, footer, etc.)
  const text = extractMainContent(html);
  
  return text;
}
```

### Cron Configuration
```typescript
// Run every hour
schedule.scheduleJob('0 * * * *', async () => {
  await checkUrlSubscriptions();
});
```

## Dependencies
- Depends on: 5.2, 5.3
- Blocks: None

## Files to Create/Modify
- `src/lib/livingDocs/urlMonitor.ts`
- `src/lib/livingDocs/contentExtractor.ts`
- `src/app/api/cron/check-subscriptions/route.ts`

## Testing
- Unit: Hash comparison, content extraction
- Integration: Mock URL fetching
- Manual: Real URL monitoring

## Complexity
**M (Medium)** â€” External service integration
