# Story 5.3: Implement Change Propagation Engine

## Metadata
- **Epic:** Epic 5 â€” Living Documentation System
- **Points:** 8
- **Priority:** High
- **Status:** ðŸ”² Not Started

## Description
Build the core engine that propagates changes from source documents to all subscribed documents.

## User Story
*As a user, I want changes to propagate through linked documentation so that derivative docs stay synchronized.*

## Acceptance Criteria
- [ ] When source doc changes, identify all subscribers
- [ ] For MIRROR behavior: auto-update content, create version
- [ ] For NOTIFY behavior: create notification for page owner
- [ ] For SUGGEST behavior: create pending update for review
- [ ] Handle circular dependencies gracefully
- [ ] Propagation depth limit (default: 3 levels)
- [ ] Propagation log for debugging
- [ ] POST `/api/agent/docs/propagate` manual trigger

## Technical Details

### Propagation Algorithm
```typescript
interface PropagationJob {
  targetPageId: string;
  sourcePageId: string;
  behavior: SubscriptionBehavior;
  depth: number;
}

async function propagateChanges(sourcePageId: string) {
  const subscribers = await getSubscribers(sourcePageId);
  const visited = new Set<string>();
  const queue: PropagationJob[] = [];
  
  for (const sub of subscribers) {
    queue.push({
      targetPageId: sub.pageId,
      sourcePageId,
      behavior: sub.behavior,
      depth: 1,
    });
  }
  
  while (queue.length > 0) {
    const job = queue.shift()!;
    
    // Prevent circular propagation
    if (visited.has(job.targetPageId)) continue;
    visited.add(job.targetPageId);
    
    // Respect depth limit
    if (job.depth > MAX_PROPAGATION_DEPTH) continue;
    
    await processSubscription(job);
    
    // Recursive propagation for MIRROR
    if (job.behavior === 'MIRROR') {
      const nextSubs = await getSubscribers(job.targetPageId);
      for (const sub of nextSubs) {
        queue.push({
          targetPageId: sub.pageId,
          sourcePageId: job.targetPageId,
          behavior: sub.behavior,
          depth: job.depth + 1,
        });
      }
    }
  }
}
```

### Behavior Handling
```typescript
async function processSubscription(job: PropagationJob) {
  const sourceContent = await getPageContent(job.sourcePageId);
  
  switch (job.behavior) {
    case 'MIRROR':
      await updatePageContent(job.targetPageId, sourceContent);
      await createVersion(job.targetPageId, 'PROPAGATED', job.sourcePageId);
      break;
      
    case 'NOTIFY':
      await createNotification(job.targetPageId, 'UPSTREAM_CHANGED', job.sourcePageId);
      break;
      
    case 'SUGGEST':
      await createPendingUpdate(job.targetPageId, sourceContent, job.sourcePageId);
      break;
  }
}
```

## Dependencies
- Depends on: 5.1, 5.2
- Blocks: None

## Files to Create/Modify
- `src/lib/livingDocs/propagationEngine.ts`
- `src/app/api/agent/docs/propagate/route.ts`
- `src/lib/livingDocs/types.ts`

## Testing
- Unit: Propagation algorithm
- Integration: Full propagation flow
- Edge case: Circular dependencies

## Complexity
**L (Large)** â€” Core business logic with edge cases
